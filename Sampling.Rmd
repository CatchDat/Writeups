---
title: "Quasirandom Sampling Methods for Synthetic Population Generation"
author: "Andrew P Smith et al"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  pdf_document:
    number_sections: true
autoNumber: all
bibliography: ref.bib
vignette: >
  %\VignetteIndexEntry{Quasirandom Sampling Methods for Synthetic Population Generation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

***
Established methods for synthesising a population from geographically aggregated data are robust and well understood. However, most rely on the potentially destructive process of "integerisation" to generate whole individuals. This paper investigates alternative methods of synthesis that are computationally efficient and result in integer populations directly. We showcase the method of 'quasirandom sampling' for population synthesis and demonstrate its ability to generate populations that match geographically aggregated data. The results show that sampling the marginals without replacement guarantees a match and that quasirandom sampling performs better than pseudorandom (or 'simple random') sampling at generating populations that fit multiple constraints. The algorithms are available in an open-source R package `humanleague`.

***

# Introduction

Iterative Proportional Fitting (IPF), sometimes known as matrix raking, is a popular and well-established technique for generating synthetic populations from marginal data.
IPF first became well-know 
, the method has various shortfalls.  will often generate fractional populations, i.e. a non-integral population in each category or state. Nor is it able to generate states containing exactly zero population. IPF requires an initial starting "seed" population (often simply setting each state to a population of one) and updates the matrix iteratively, stopping when the marginals are matched to withing some specified tolerance.

Integerisation is a common technique used to convert fractional populations into integer ones. However these methods are not guaranteed to break contraints, even though the fractional input population may satisfy them. The implementation in the `R` package `rakeR` for example, only guarantees to conserve the total population, and may create a difference between the population and the marginals.

IPF does, however, result in degenerate populations with little or no detectable correlation between between the marginals.

In this paper we investigate sampling techniques where a population matrix is built exclusively in the integer domain We show that this technique can only work effectively if a quasirandom (as opposed to a pseudorandom) number generator is used, and this in itself is not sufficient to work in all cases. We also show that this problem can be overcome by combining the quasirandom generator with a sampling-without-replacement algorithm. We then look at the statistical properties of the resulting populations, comparing them to populations generated with the IPF algorithm.

# Theory

## Quasirandom Numbers

Quasirandom numbers, often referred to as low discrepancy sequences, are preferential to pseudorandom numbers in many applications, despite not having some of the (appearance of) randomness that good pseudorandom generators possess. In this work we focus on the Sobol quasirandom sequence. (refs Bratley and Fox, Joe & Kuo). 

Sobol, as with other quasirandom sequences, have an inherent dimensionality and a relatively short period - the sequence is exhausted once every integer in the sample space has been sampled. Successive samples tend to evenly fill the sample space, and thus successive samples lack independence. Conversely, a good pseudorandom generator has no discernible dependence between variates often has a much longer period, allowing for very large samples to be taken.

For applications such as numerical integration, Sobol sequences converge at a rate of $\approx1/N$ (actually $(ln N)^D/N$ (Teukolsky et al, Numerical Recipes in C, 2nd Ed 1992)) compared to $\approx1/\sqrt N$ for a pseudorandom generator, and thus require far fewer samples to achieve the same level of accuracy.

Quasirandom sequences are not seeded like pseudorandom generators. To avoid repetition, and for better degeneracy, it is recommended to discard a number of variates on initialisation (Joe and Kuo 2003), and on subsequent sampling continue the sequence from its previous position.

For comparison in the analysis below, we use the MT19937 variant of the Mersenne Twister pseudorandom generator [@matsumoto_mersenne_1998].

### Sampling without Replacement

Given discretely distributed population $P$ with integral frequencies $\{f_0,f_1,...f_n\}$, a random sample $i \in \{0...n\}$ has probability 

$$p(i) = \frac{f_i}{\sum\limits_{j=0}^{n}f_j}$$

Once a sample $i$ is taken the distribution is adjusted to $\{f_0,f_1,...f_i-1,....f_n\}$. Once $f_i$ has reached zero no further samples can take the value $i$ since $p(i) = 0$. 

Since $f_i$ cannot be oversampled, this implies that $f_{j\neq{i}}$ cannot be undersampled. If follows that after sampling $P$ variates, $f_i = 0 \space\forall\space i \in \{0...n\}$. Thus there is a guarantee that the distibution is sampled exactly.

## Problem Statement

A mathematical statement of the microsimulation problem is as follows:

(In the notation below, the index $i$ is scalar and refers to a particular dimension. The index $\mathbf{k}$ is a vector index $\{k_1, k_2,...k_D\}$ of length $D$, the dimensionality of the problem.)

Given a population $P$ and a set of $D$ marginal vectors $\mathbf{m}_i$ of length $l_i$ such that we have $S$ possible states

$$S=\prod\limits_{i}l_i$$

Find a contingency table $\mathbf T$ in $D$ dimensions such that

$$\sum\limits_{\mathbf{k}, k_i fixed} \mathbf{T}_\mathbf{k} = \mathbf{m}_i$$

in other words each element of $\mathbf{m}_i$ is the sum of all elements in $\mathbf{T}$ for a fixed value of $k_i$. We define this as constraint (1).

Each marginal sum and the sum of the elements of contingency table must equal the population $P$:

$$\sum\limits \mathbf{m}_{i} = \sum\limits_\mathbf{k} \mathbf{T} = P$$ 

We define this as constraint (2). Finally, constraint (3) restricts the elements to the natural numbers: 

$${\mathbf{T} \in \mathbb{N}^S,\mathbf{m}_i} \in \mathbb{N}^{l_i}$$ 

In the general case this is an ill-posed problem as there are not enough constraints for a unique solution. Hence the need to resort to iterative or optimisation-type solutions, such as IPF, simulated annealing, maximum likelihood, chi-squared fitting, least-squares fitting.

# The Algorithms

## Integer Quasirandom with-Replacement Sampling (IQRS)

1. Create a $D$-dimensional discrete with-replacement distribution using the marginals $\mathbf{m}_i$

2. Sample $P$ quasirandom variates from this distribution to create a "seed" population $\mathbf{T}$. Specifically, we sample a value of $\mathbf{k}$ and increment the value of $\mathbf{T}_k$. Thus $\mathbf{T}$ will - by construction - satisfy constraints (2) and (3). The next step is to check, and adjust if necessary, the population such that constraint (1) is met.

3. Calculate the residual vector $\mathbf{r}_i$, the difference between the seed population and marginal $\mathbf{m}_i$: 
$$\mathbf{r}_i = \sum\limits_{\mathbf{k}, k_i fixed} \mathbf{T}_k - \mathbf{m}_i$$
If all elements of $\mathbf{r}_i$ are zero, constraint (1) is satisfied in dimension $i$. If not, find an index $\mathbf{k}$ in $\mathbf{T}$ such that subtracting $\mathbf{r}_i$ will not result in negative values in $\mathbf{T}$

4. If $\mathbf{k}$ exists, perform the subtraction:
$$\mathbf{T}_{\mathbf{k}, k_i fixed} \leftarrow \mathbf{T}_{\mathbf{k}, k_ifixed} - \mathbf{r}_i$$

5. Repeat step 3. as necessary for each dimension.

6. Compute a $\chi^2$ statistic and a p-value.

Note that the algorithm will fail if, in any dimension, there is a nonzero residual and no index $\mathbf{k}$ from which the residual can be subtracted without resulting in negative elements of $\mathbf{T}$. This likelihood is vastly reduced by using quasirandom sampling. 

## Integer Without-Replacement Sampling (IWRS)

1. Create an N-dimensional discrete without-replacement distribution using the marginals $\mathbf{m}_i$

2. Sample $P$ random variates from this distribution to create a population $\mathbf{T}$. Specifically, we sample a value of $\mathbf{k}$ and increment the value of $\mathbf{T}_\mathbf{k}$, repeating until our distribution is fully depleted. Constructing the problem in this way automatically ensures that all constraints are automatically met.

3. Compute a $\chi^2$ statistic and a p-value.

## A Worked Example of IQRS

We consider a 2 dimensional case here for simplicity, for a population $P$ of 100 individuals with two categorical characteristics. Let the marginal vectors be $\mathbf{m}_0=\{51,49\}$ and $\mathbf{m}_1=\{35,40,25\}$, giving the population 6 possible states.    

We construct a bivariate discrete distibution using the marginals which will have a probability density

$$p_{ij} = \frac{(\mathbf{m}_0)_i(\mathbf{m}_1)_j}{\sum\limits_i\mathbf{m}_0\sum\limits_j\mathbf{m}_1}$$ 

We take $P$ random samples $(i,j)$ from this distribution to create a seed population $\mathbf{T}$ (in bold), which for example may look like:

 $\mathbf{m}_0\setminus\mathbf{m}_1$ |  35    | 40     | 25     | $\mathbf{r}_0$
:-----------------------------------:|--------|--------|--------|----
            51                       | **19** | **20** | **11** | *-1*
            49                       | **17** | **20** | **13** | *+1*
        $\mathbf{r}_1$               |  *+1*  |  *0*   | *-1*   |

The row and column sums do not quite match the marginals. The residuals (italic, from equation 5) are $\mathbf{r}_0=\{-1, 1\}$ and $\mathbf{r}_1=\{1,0,-1\}$.

To correct the population we subtract $\mathbf{r}_0$ from any one column (in this case no choice of column will result in a negative value). Selecting the first column, the population becomes:

 $\mathbf{m}_0\setminus\mathbf{m}_1$ |  35    | 40     | 25     | $\mathbf{r}_0$
:-----------------------------------:|--------|--------|--------|----
            51                       | **20** | **20** | **11** | *0*
            49                       | **16** | **20** | **13** | *0*
        $\mathbf{r}_1$               |  *+1*  |  *0*   |  *-1*  |
    
which now matches $\mathbf{m}_0$. Next we subtract $\mathbf{r}_1$ from the any one row (again no choice of row will result in a negative value). Selecting the first row, the population becomes:

 $\mathbf{m}_0\setminus\mathbf{m}_1$ |  35    | 40     | 25     | $\mathbf{r}_0$
:-----------------------------------:|--------|--------|--------|----
            51                       | **19** | **20** | **12** | *0*
            49                       | **16** | **20** | **13** | *0*
        $\mathbf{r}_1$               |  *0*   |  *0*   |  *0*   |

which results in a population that now matches both marginals. It should be noted that in this example there are six possible ways that the seed population could be adjusted.  

The IWRS algorithm, being simpler, does not warrant an example. The algorithm description above suffices.

## The Implementation

The algorithms are implemented in an `R` package called `humanleague`, writen in `C++11` and `C` and interfaced using `Rcpp`. We used open source implementations of the Sobol sequence generator [@johnson_stevengj] (Johnson 2016) and the incomplete gamma function [@burkardt_asa032_????] (Burkhardt 2008). The remainder of the code was developed by the authors. The Sobol sequence generator is implemented in such a way that it is not reset each time a population is requested, allowing different populations to be generated each time. 

The intent is to submit the package to the offical CRAN repository, but until then it is available at [https://github.com/CatchDat/humanleague](https://github.com/CatchDat/humanleague).

The implementation supports dimensionalities up to the 12, although this limit is arbitrary and could be increased if necessary. Input is simply a list of marginal vectors

The output is broadly compatible with the established `mipfp` (Barthelemy & Suesse 2016) `R` package: 

- $D$-dimensional population array
- $D$-dimensional probability array
- boolean value indicating convergence
- maximum value of each residual vector
- $\chi^2$ statistic
- p-value

# Comparison of Methods

## Statistical Properties

We compare the two algorithms to IPF using a number of two-dimensional test cases.

No integerisation was done to the IPF data (using e.g. the `R` package `rakeR`) due to that fact that integerisation only guarantees constraints (1) and (3) are met, and can in fact break constraint (2) on a non-integer input that meets it. The $\chi^2$ value resulting from IPF is thus likely to be slightly lower due to the fact the numbers need not be integral.

IPF was initialised with a random seed array, each element uniformly distributed in $[0,2)$

The first three tests are made-up examples. The remainder are marginal figures derived from 2011 UK census data at the MSOA level (mid-layer super output area), with one dimension representing person status in terms of age, sex, and economic activity, the other their workplace location.

Interestingly, IPF performed least well on the simple tests, generating the lowest mean p-values.

In the table below $\bar{c}$ refers to the convergence success rate, and $\bar{p}$ refers to the mean p-value.

 Pop | States | N | IQRS $\bar{c}$ | IQRS $\bar{p}$  | IWRS $\bar{c}$ | IWRS $\bar{p}$ | IPF $\bar{c}$ | IPF $\bar{p}$  
:---:|---|---|--------|--------|--------|--------|--------|--------|-------|-------|------
  20|    4|1000|1|0.78|1|0.79|1|0.48
 125|   25|1000|1|0.91|1|0.91|1|0.06
 935|   49|1000|1|0.74|1|0.86|1|0.03
4958|16032|1000|0|0.82|1|0.81|1|1
4098|11760|1000|0|0.84|1|0.8 |1|1
4029|11904|1000|0|0.81|1|0.8 |1|1
4989|14640|1000|0|0.8 |1|0.79|1|1
5219|15168|1000|0|0.79|1|0.79|1|1

A more detailed analysis was performed on two evenly distributed marginal vectors of length 10 and a population $P$ = 100 and number of states $S$ = 100, sampling 10000 populations.

Firstly we used the IQRS algorithm with a PRNG, and found only one attempt reached a valid population, i.e. a success rate of 0.01%. This confirms our earlier reasoning that quasirandom numbers are essential for the algorithm.

```{r, echo=FALSE, out.width="75%", fig.cap="Distribution of p-values of IQRS."}
knitr::include_graphics("figures/iqrs_pvalue_dist.png")
```

Secondly, reverting back to a QRNG we examined the distribution of p-values for IQRS, which can be seen in figure 1. In the analysis we assigned a p-value of zero to any case where the population did not match the marginals, which happened about 15% of the time.

Next we compared the performance of IWRS using a PRNG and a QRNG. Since we knew the algorithm is guaranteed to work regardless of the RNG used, we again looked at the distribution of p-values, which can be seen in figures 2 and 3. There is a marked difference between the two, with the PRNG implementation being broadly symmetric with a bias toward mid-range values, whereas the QRNG implementation is very strongly biased toward high p-values. 

```{r, echo=FALSE, out.width="75%", fig.cap="Distribution of p-values of IWRS using PRNG."}
knitr::include_graphics("figures/iwrs_prng_pvalue_dist.png")
```

```{r, echo=FALSE, out.width="75%", fig.cap="Distribution of p-values of IWRS using QRNG"}
knitr::include_graphics("figures/iwrs_pvalue_dist.png")
```

If the result of the IWRS algorithm is used as the seed for the IPF algorithm, the latter simply returns the seed matrix. This happens even when we deliberately pick a result with a low (>0.005) p-value.

## Performance

The performance of the algorithms is shown, mean execution time in milliseconds using the same tests as above. Since computers vary widely in performance for numerous reasons, the numbers should be interpreted relatively.

Pop | States | N | IQRS | IWRS | IPF 
:--:|-----|----|----|----|-----
  20|    4|1000|0.03|0.03| 1.99
 125|   25|1000|0.04|0.04| 2.9
 935|   49|1000|0.07|0.07| 2.05
4958|16032|1000|0.95|0.92|46.78
4098|11760|1000|0.77|0.69|32.07
4029|11904|1000|0.8 |0.68|30.82
4989|14640|1000|0.95|0.85|43.71
5219|15168|1000|0.96|0.86|46.73 

ref Mark/Robin paper(s)

# Discussion

The algorithms presented here have some significant advantages over traditional IPF. Notably, integer populations in many cases are preferable to fractional ones, and integerising fractional populations generated by other methods may result in populations that no longer match the marginals. 

In terms of performance, they are significantly faster than the IPF implementation we compared against (`mipfp`). This is likely due to the fact the algorithms are not iterative in nature, and that the implementation is in a low-level language. The performance of population synthesis is unlikely to be the bottleneck in any workflow, so performance is not considered a major advantage.

The main disadvantage of IQRS is that it may not always be able to generate a valid population. IWRS came about as an evolution (and simplification) of the algorithm that resolved this issue. 

The IWRS algorithm works well even for sparse populations.

Another possible disadvantage is that both IQRS and IWRS generally result in populations with lower p-values than IPF. We would expect end-users to check the p-value against a suitable threshhold, and reject and resample if necessary.

# Conclusion

Although IQRS may be of limited use due to the fact it cannot always generate a population, we believe IWRS is promising as a technique that could complement existing techniques, especially when integral populations are important. We do recommend that users satisfy themselves that the resulting population is adequately degenerate.

We anticipate further investigation of the algorithms for deliberately generating populations with low p-values, in cases where the marginals are known to be strongly correlated. We have not studied the application of these algorithms for anonymisation of populations [@nowok_synthpop:_2016]

# Acknowledgements

Catch! project funding

# References

```{r}
# Get bibliography (run once from project root)
u = "https://www.zotero.org/api/groups/418217/collections/MP7NS3SC/items/top?limit=100&format=bibtex&v=1"
b = httr::GET(url = u, httr::write_disk("ref.bib", overwrite = T))
```



@kavroudakis_sms:_2015 focus on the spatial variability of individual-level dat.
